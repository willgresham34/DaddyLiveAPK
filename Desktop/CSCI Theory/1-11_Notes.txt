__ Strings
(*) a symbol is a printable character of length 1
(*) An alphabet is a set of symbols that is both finite and non empty
(*) Let \S be an alphabet. A String over \S is a sequence of symbols w_1w_2w_3... where all sybmols belond to \S
(*) The empty string (written \e) is the string consisting of zero symbols
\info the empty string is said to be a string over any alaphabet
__Operation String
(*) The concatenation of two string x and y (written x\.y or xy), or a string x with a symbol y, satisfies the following:
[1] \A c \S \sig, \e\.c=c\.\e=c
[2] \A x,y,z \S \s*, (x\.y\.z=x\.(y\.z) associativity
(*) let w be a string over some alphabet \S. The length of W (written | w | ) is defined using the follwoing recursive definition:
@{base} Base Step: | \e | = 0
@{loop} Recursion Step: \A w \in \S
[eg] A recursive definition is used to define a  value that takes multple steps to formulate. The table below illustrates the computations  of the of the length of the string abaa. The steps defined in the recursive definition are labeled:
|abaa| = 1 + |abaa|
>> = 1 + 1 + |aa|        rec
>> = 1 + 1 + 1 + |a|    rec
>> = 1 + 1 + 1 + 1 + |\e| rec
>> = 1 + 1 + 1 + 1 + 0    base
>> = 4
(*) let w be a string over some alphabet \S. The reverse of W (written | w^R | ) is defined using the follwoing recursive definition:
@{base} Base Step: | \e^R | = \e
@{loop} Recursion Step: \A w \in \S* \Ac\in\S, [(cw)^R = w^R \. c]
Example:
(abab)^R = (bab)^R \. a
>> = (ab)^R \. b \. a
>> = b^R \. a \.  b \. a
>> = \e^R \. b \. a \. b \. a
>> = baba
___ Languages
(*) Let \S be an alphabet. A language over \S is a set of finite strings over \S.
(*) Let \S be an alphabet. \S* is the universe of all strings over \S. The set of \S* is defined using all the following recursive definition:
@{base} Base step: \e \in \S*
\S* contains the empty string
@{loop} Recursion step: \Aw\in\S* \Ac\in\S [w\.c\in\S*]
[eg] Let \S={a}
[1] \S* = {\e}
[2] \S* = {\e,a}
[3] \S*  = {\e,a,aa}
...
____ Deterministic finite automata
//
:+ dfa Example
title Example DFA
Q={q1,q2}
S={0,1}
d(q1,0)=q1
d(q1,1)=q2
d(q2,0)=q1
d(q2,1)=q2
q0=q1
F={q2}
done.
//
(*) A !{@dfa} (DFA) is a 5-tuple:
> [1] Q - finite and nonempty set of states
> [2] \S - input alphabet
> [3] \d - transition @fn
>>> @{a} \d: Q\*\S->Q
> [4] q_0\in Q - initial state
> [5] F\subsetQ - set of final states
//
:sim Example 11010
//
___ @{state} Logical Analysis
//
:fig table
State # Meaning
q_1 # The last symbol read was 0 or we have read \e or we have no previous inputs.
q_2 # The last symbol read was 1.
done.